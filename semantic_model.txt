# === Model Objective/Context ===
# This model is designed for analyzing store sales and return performance to identify trends and areas for improvement.

# === COMMON DATA WAREHOUSE MISTAKES TO AVOID ===
# üö´ NEVER join fact tables directly (store_sales JOIN store_returns)
# üö´ NEVER use FROM store_sales, store_returns with cross joins
# üö´ NEVER assume fact tables can be joined on any column
# üö´ NEVER bypass dimension tables when combining facts
# 
# ‚úÖ ALWAYS aggregate fact tables separately first
# ‚úÖ ALWAYS join through shared dimension keys
# ‚úÖ ALWAYS use FULL OUTER JOIN for fact combinations
# ‚úÖ ALWAYS use COALESCE for NULL handling in outer joins

# === Instruction: Semantic Model Consistency ===
#   You are a SQL query generator and analyst. Given a user query:
#   generate a single, correct SQL query based on the provided semantic model. Do not explain, just produce SQL.
# - Always use the defined semantic model for all query generation, reasoning, or analysis.
# - Use only the measures, dimensions, and relationships explicitly defined in the semantic model.
# - Never join fact tables directly; use shared dimensions as join bridges.
# - Prefer named measures over repeating raw expressions.
# - Always respect the star schema layout.
# - Do not assume columns or relationships not explicitly defined here.
# - Return answer in duckdb sql if generating SQL.
# - Add the question as a comment in the SQL generated.
# - When generating SQL, adhere to Kimball dimensional modeling principles for this model:
#   - Join fact tables (store_sales, store_returns) ONLY to their related dimension tables (date_dim, store, customer, item) using the defined foreign keys.
#   - To combine data from store_sales and store_returns, join both fact tables to a common dimension table. DO NOT join fact tables directly to each other.
#   - Aggregate measures using the defined expressions and group results by dimension attributes.
#   - Always group to avoid having double null from two dimensions in the results.

# === CRITICAL RULE: NO FACT-TO-FACT JOINS ===
# ‚ùå NEVER DO THIS: SELECT * FROM store_sales ss JOIN store_returns sr ON ss.column = sr.column
# ‚ùå NEVER DO THIS: FROM store_sales, store_returns WHERE store_sales.x = store_returns.x
# ‚úÖ ALWAYS DO THIS: Use separate CTEs/subqueries for each fact table, then join results via shared dimensions
# ‚úÖ PATTERN: WITH sales_data AS (SELECT ... FROM store_sales JOIN dimensions), returns_data AS (SELECT ... FROM store_returns JOIN dimensions) SELECT ... FROM sales_data JOIN returns_data ON shared_dimension_key
# 
# FACT-TO-FACT JOINS CAUSE:
# - Data multiplication/duplication
# - Incorrect aggregations  
# - Wrong business results
# - Performance issues
#
# ALWAYS use the CTE pattern shown in verified_queries for combining fact tables. 

semantic_model:
  measures:
    - name: total_sales
      expression: SUM(store_sales.ss_sales_price * store_sales.ss_quantity)
      description: "Total sales revenue across all transactions."
    - name: total_quantity
      expression: SUM(store_sales.ss_quantity)
      description: "Total number of items sold."
    - name: total_returns
      expression: SUM(store_returns.sr_return_amt)
      description: "Total value of returned items."
    - name: net_sales
      expression: SUM(store_sales.ss_sales_price * store_sales.ss_quantity) - SUM(store_returns.sr_return_amt)
      description: "Net sales revenue after accounting for returns."
    - name: return_rate
      expression: (SUM(store_returns.sr_return_amt) / NULLIF(SUM(store_sales.ss_sales_price * store_sales.ss_quantity), 0)) * 100
      description: "Return amount as a percentage of total sales."

  dimensions:
    date_dim:
      primary_key: d_date_sk
      columns:
        - name: d_year
          type: integer
          sample_values: [2001, 2010, 2023]
        - name: d_moy
          type: integer
          sample_values: [1, 6, 12]
        - name: d_dow
          type: integer
          sample_values: [1, 4, 7]
        - name: d_dom
          type: integer
          sample_values: [5, 15, 25]
        - name: d_qoy
          type: integer
          sample_values: [1, 2, 4]
        - name: d_holiday
          type: boolean
          sample_values: ["Y", "N"]
        - name: d_weekend
          type: boolean
          sample_values: ["Y", "N"]
    store:
      primary_key: s_store_sk
      columns:
        - name: s_store_name
          type: string
          sample_values: ["SuperMart", "MegaStore", "MarketY"]
        - name: s_number_employees
          type: integer
          sample_values: [120, 245, 300]
        - name: s_floor_space
          type: integer
          sample_values: [4500000, 5250760, 6000000]
        - name: s_hours
          type: string
          sample_values: ["9AM-5PM", "8AM-4PM", "10AM-6PM"]
        - name: s_manager
          type: string
          sample_values: ["Emily Johnson", "Michael Smith", "William Ward"]
        - name: s_city
          type: string
          sample_values: ["Centerville", "Midway", "Springfield"]
        - name: s_state
          type: string
          sample_values: ["NY", "TN", "CA"]
        - name: s_country
          type: string
          sample_values: ["United States", "Canada", "Mexico"]
    customer:
      primary_key: c_customer_sk
      columns:
        - name: c_birth_year
          type: integer
          sample_values: [1932, 1985, 2000]
        - name: c_birth_country
          type: string
          sample_values: ["UNITED STATES", "INDIA", "CAMEROON"]
        - name: c_preferred_cust_flag
          type: boolean
          sample_values: ["Y", "N"]
    item:
      primary_key: i_item_sk
      columns:
        - name: i_item_desc
          type: string
          sample_values: ["High-quality laptop.", "Gaming keyboard.", "Wireless mouse."]
          description: "Description of the item."
        - name: i_brand
          type: string
          sample_values: ["BrandA", "BrandB", "BrandC"]
          description: "Brand of the item."
        - name: i_class
          type: string
          sample_values: ["Electronics", "Accessories", "Peripherals"]
          description: "Class of the item."
        - name: i_category
          type: string
          sample_values: ["Computers", "Gadgets", "Office"]
          description: "Category of the item."
        - name: i_color
          type: string
          sample_values: ["Black", "White", "Gray"]
          description: "Color of the item."
        - name: i_units
          type: string
          sample_values: ["pcs", "boxes", "sets"]
          description: "Units of measurement for the item."
        - name: i_container
          type: string
          sample_values: ["Box", "Plastic", "None"]
          description: "Container type for the item."
        - name: i_product_name
          type: string
          sample_values: ["UltraBook X", "ProKey Keyboard", "ErgoMouse"]
          description: "Product name of the item."

  fact_tables:
    - name: store_sales
      description: "Fact table containing all store sales transactions."
      foreign_keys:
        - ss_store_sk ‚Üí store.s_store_sk
        - ss_customer_sk ‚Üí customer.c_customer_sk
        - ss_item_sk ‚Üí item.i_item_sk
        - ss_sold_date_sk ‚Üí date_dim.d_date_sk
    - name: store_returns
      description: "Fact table capturing product returns."
      foreign_keys:
        - sr_store_sk ‚Üí store.s_store_sk
        - sr_customer_sk ‚Üí customer.c_customer_sk
        - sr_item_sk ‚Üí item.i_item_sk
        - sr_returned_date_sk ‚Üí date_dim.d_date_sk

  # === FACT TABLE JOIN RULES ===
  # These fact tables are at the SAME GRAIN and should NEVER be joined directly.
  # They represent different business events (sales vs returns) that happen independently.
  # 
  # REQUIRED PATTERN for combining fact tables:
  # 1. Create separate CTEs for each fact table with their dimension joins
  # 2. Aggregate each fact table separately by the desired dimensions
  # 3. Join the aggregated results using FULL OUTER JOIN on dimension keys
  # 4. Use COALESCE to handle NULLs from the outer join
  #
  # EXAMPLE SAFE PATTERN:
  # WITH sales_by_store AS (
  #   SELECT s.s_store_name, SUM(ss.ss_sales_price * ss.ss_quantity) as total_sales
  #   FROM store_sales ss JOIN store s ON ss.ss_store_sk = s.s_store_sk
  #   GROUP BY s.s_store_name
  # ), returns_by_store AS (
  #   SELECT s.s_store_name, SUM(sr.sr_return_amt) as total_returns  
  #   FROM store_returns sr JOIN store s ON sr.sr_store_sk = s.s_store_sk
  #   GROUP BY s.s_store_name
  # )
  # SELECT COALESCE(sales.s_store_name, returns.s_store_name) as store_name,
  #        COALESCE(sales.total_sales, 0) - COALESCE(returns.total_returns, 0) as net_sales
  # FROM sales_by_store sales FULL OUTER JOIN returns_by_store returns 
  #      ON sales.s_store_name = returns.s_store_name

  anti_patterns:
    # These are FORBIDDEN query patterns that will produce incorrect results:
    
    - pattern: "Direct fact-to-fact joins"
      wrong_example: |
        -- ‚ùå WRONG: This will multiply data and give incorrect results
        SELECT s.s_store_name, 
               SUM(ss.ss_sales_price * ss.ss_quantity) - SUM(sr.sr_return_amt) as net_sales
        FROM store_sales ss 
        JOIN store_returns sr ON ss.ss_store_sk = sr.sr_store_sk
        JOIN store s ON ss.ss_store_sk = s.s_store_sk
        GROUP BY s.s_store_name
      
      why_wrong: "Multiplies sales data by number of returns and vice versa, creating inflated totals"
      
    - pattern: "Cross join with WHERE clause"
      wrong_example: |
        -- ‚ùå WRONG: Implicit cross join between facts
        SELECT SUM(ss.ss_sales_price * ss.ss_quantity) - SUM(sr.sr_return_amt) as net_sales
        FROM store_sales ss, store_returns sr
        WHERE ss.ss_store_sk = sr.sr_store_sk
        
      why_wrong: "Same issue as direct join - creates Cartesian product between fact tables"
      
    - pattern: "Single query without CTEs for fact combination"
      wrong_example: |
        -- ‚ùå WRONG: Trying to calculate net sales in single query with fact tables
        SELECT s.s_store_name,
               SUM(CASE WHEN ss.ss_sales_price IS NOT NULL 
                        THEN ss.ss_sales_price * ss.ss_quantity ELSE 0 END) -
               SUM(CASE WHEN sr.sr_return_amt IS NOT NULL 
                        THEN sr.sr_return_amt ELSE 0 END) as net_sales
        FROM store s
        LEFT JOIN store_sales ss ON s.s_store_sk = ss.ss_store_sk  
        LEFT JOIN store_returns sr ON s.s_store_sk = sr.sr_store_sk
        GROUP BY s.s_store_name
        
      why_wrong: "Creates Cartesian product between sales and returns, inflating numbers"

  verified_queries:
    - question: give me return rate by age group
      sql: |
        WITH SalesAge AS (
          -- Calculate total sales per customer age group, determining age at the time of sale
          SELECT
            CASE
              WHEN (
                d.d_year - c.c_birth_year
              ) < 20 THEN '< 20'
              WHEN (
                d.d_year - c.c_birth_year
              ) BETWEEN 20 AND 29 THEN '20-29'
              WHEN (
                d.d_year - c.c_birth_year
              ) BETWEEN 30 AND 39 THEN '30-39'
              WHEN (
                d.d_year - c.c_birth_year
              ) BETWEEN 40 AND 49 THEN '40-49'
              WHEN (
                d.d_year - c.c_birth_year
              ) BETWEEN 50 AND 59 THEN '50-59'
              WHEN (
                d.d_year - c.c_birth_year
              ) >= 60 THEN '60+'
              ELSE 'Unknown'
            END AS age_group,
            SUM(ss.ss_sales_price * ss.ss_quantity) AS total_sales_amt -- Corresponds to total_sales measure
          FROM store_sales AS ss
          JOIN date_dim AS d
            ON ss.ss_sold_date_sk = d.d_date_sk
          JOIN customer AS c
            ON ss.ss_customer_sk = c.c_customer_sk
          WHERE
            c.c_birth_year IS NOT NULL AND d.d_year IS NOT NULL -- Filter out records where age cannot be calculated
          GROUP BY
            1
        ), ReturnsAge AS (
          -- Calculate total returns per customer age group, determining age at the time of return
          SELECT
            CASE
              WHEN (
                d.d_year - c.c_birth_year
              ) < 20 THEN '< 20'
              WHEN (
                d.d_year - c.c_birth_year
              ) BETWEEN 20 AND 29 THEN '20-29'
              WHEN (
                d.d_year - c.c_birth_year
              ) BETWEEN 30 AND 39 THEN '30-39'
              WHEN (
                d.d_year - c.c_birth_year
              ) BETWEEN 40 AND 49 THEN '40-49'
              WHEN (
                d.d_year - c.c_birth_year
              ) BETWEEN 50 AND 59 THEN '50-59'
              WHEN (
                d.d_year - c.c_birth_year
              ) >= 60 THEN '60+'
              ELSE 'Unknown'
            END AS age_group,
            SUM(sr.sr_return_amt) AS total_returns_amt -- Corresponds to total_returns measure
          FROM store_returns AS sr
          JOIN date_dim AS d
            ON sr.sr_returned_date_sk = d.d_date_sk
          JOIN customer AS c
            ON sr.sr_customer_sk = c.c_customer_sk
          WHERE
            c.c_birth_year IS NOT NULL AND d.d_year IS NOT NULL -- Filter out records where age cannot be calculated
          GROUP BY ALL
        )
        -- Final calculation joining sales and returns by age group and computing return rate
        SELECT
          COALESCE(sa.age_group, ra.age_group) AS customer_age_group,
          COALESCE(sa.total_sales_amt, 0) AS total_sales,
          COALESCE(ra.total_returns_amt, 0) AS total_returns,
          -- Calculate return rate, handling potential division by zero
          (
            COALESCE(ra.total_returns_amt, 0) / NULLIF(COALESCE(sa.total_sales_amt, 0), 0)
          ) * 100 AS return_rate
        FROM SalesAge AS sa
        FULL OUTER JOIN ReturnsAge AS ra
          ON sa.age_group = ra.age_group -- Join on the calculated age group
        GROUP BY ALL
        ORDER BY
          customer_age_group;
    
    
    - question: net sales by store name
      sql: |
        -- net sales by store name
        WITH store_sales_agg AS (
            SELECT
                st.s_store_name,
                SUM(ss.ss_sales_price * ss.ss_quantity) AS total_sales
            FROM store_sales AS ss
            INNER JOIN store AS st ON ss.ss_store_sk = st.s_store_sk
            GROUP BY st.s_store_name
        ), store_returns_agg AS (
            SELECT
                st.s_store_name,
                SUM(sr.sr_return_amt) AS total_returns
            FROM store_returns AS sr
            INNER JOIN store AS st ON sr.sr_store_sk = st.s_store_sk
            GROUP BY st.s_store_name
        )
        SELECT
            COALESCE(ss.s_store_name, sr.s_store_name) AS store_name,
            COALESCE(ss.total_sales, 0) - COALESCE(sr.total_returns, 0) AS net_sales -- Using the net_sales logic
        FROM store_sales_agg AS ss
        FULL OUTER JOIN store_returns_agg AS sr ON ss.s_store_name = sr.s_store_name
        GROUP BY ALL
        ORDER BY store_name;
    - question: net sales
      sql: |  
        -- net sales 
        WITH store_sales_agg AS (
            SELECT
                SUM(ss.ss_sales_price * ss.ss_quantity) AS total_sales
            FROM store_sales AS ss
        ), store_returns_agg AS (
            SELECT
                SUM(sr.sr_return_amt) AS total_returns
            FROM store_returns AS sr
        )
        SELECT
            COALESCE(ss.total_sales, 0) - COALESCE(sr.total_returns, 0) AS net_sales -- Using the net_sales logic
        FROM store_sales_agg ss, store_returns_agg sr
    - question: return rate
      sql: |   
              -- return rate
              WITH store_sales_agg AS (
                  SELECT
                      SUM(ss.ss_sales_price * ss.ss_quantity) AS total_sales
                  FROM store_sales AS ss
              ), store_returns_agg AS (
                  SELECT
                      SUM(sr.sr_return_amt) AS total_returns
                  FROM store_returns AS sr
              )
              SELECT
                  (COALESCE(sr.total_returns, 0) / NULLIF(COALESCE(ss.total_sales, 0), 0))  * 100 AS return_rate
              FROM store_sales_agg ss, store_returns_agg sr
